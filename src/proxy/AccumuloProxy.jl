#
# Autogenerated by Thrift Compiler (1.0.0-dev)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING



# types encapsulating arguments and return values of method login

type login_args
  principal::UTF8String
  loginProperties::Dict{UTF8String,UTF8String}
  login_args() = (o=new(); fillunset(o); o)
end # type login_args

type login_result
  success::Vector{UInt8}
  ouch2::AccumuloSecurityException
  login_result() = (o=new(); fillunset(o); o)
  login_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type login_result
meta(t::Type{login_result}) = meta(t, Symbol[:success, :ouch2], Int[0, 1], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method addConstraint

type addConstraint_args
  login::Vector{UInt8}
  tableName::UTF8String
  constraintClassName::UTF8String
  addConstraint_args() = (o=new(); fillunset(o); o)
end # type addConstraint_args

type addConstraint_result
  success::Int32
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  addConstraint_result() = (o=new(); fillunset(o); o)
  addConstraint_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type addConstraint_result
meta(t::Type{addConstraint_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method addSplits

type addSplits_args
  login::Vector{UInt8}
  tableName::UTF8String
  splits::Set{Vector{UInt8}}
  addSplits_args() = (o=new(); fillunset(o); o)
end # type addSplits_args

type addSplits_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  addSplits_result() = (o=new(); fillunset(o); o)
end # type addSplits_result
meta(t::Type{addSplits_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method attachIterator

type attachIterator_args
  login::Vector{UInt8}
  tableName::UTF8String
  setting::IteratorSetting
  scopes::Set{Int32}
  attachIterator_args() = (o=new(); fillunset(o); o)
end # type attachIterator_args

type attachIterator_result
  ouch1::AccumuloSecurityException
  ouch2::AccumuloException
  ouch3::TableNotFoundException
  attachIterator_result() = (o=new(); fillunset(o); o)
end # type attachIterator_result
meta(t::Type{attachIterator_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method checkIteratorConflicts

type checkIteratorConflicts_args
  login::Vector{UInt8}
  tableName::UTF8String
  setting::IteratorSetting
  scopes::Set{Int32}
  checkIteratorConflicts_args() = (o=new(); fillunset(o); o)
end # type checkIteratorConflicts_args

type checkIteratorConflicts_result
  ouch1::AccumuloSecurityException
  ouch2::AccumuloException
  ouch3::TableNotFoundException
  checkIteratorConflicts_result() = (o=new(); fillunset(o); o)
end # type checkIteratorConflicts_result
meta(t::Type{checkIteratorConflicts_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method clearLocatorCache

type clearLocatorCache_args
  login::Vector{UInt8}
  tableName::UTF8String
  clearLocatorCache_args() = (o=new(); fillunset(o); o)
end # type clearLocatorCache_args

type clearLocatorCache_result
  ouch1::TableNotFoundException
  clearLocatorCache_result() = (o=new(); fillunset(o); o)
end # type clearLocatorCache_result
meta(t::Type{clearLocatorCache_result}) = meta(t, Symbol[:ouch1], Int[1], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method cloneTable

type cloneTable_args
  login::Vector{UInt8}
  tableName::UTF8String
  newTableName::UTF8String
  flush::Bool
  propertiesToSet::Dict{UTF8String,UTF8String}
  propertiesToExclude::Set{UTF8String}
  cloneTable_args() = (o=new(); fillunset(o); o)
end # type cloneTable_args

type cloneTable_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  ouch4::TableExistsException
  cloneTable_result() = (o=new(); fillunset(o); o)
end # type cloneTable_result
meta(t::Type{cloneTable_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3, :ouch4], Int[1, 2, 3, 4], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method compactTable

type compactTable_args
  login::Vector{UInt8}
  tableName::UTF8String
  startRow::Vector{UInt8}
  endRow::Vector{UInt8}
  iterators::Vector{IteratorSetting}
  flush::Bool
  wait::Bool
  compactionStrategy::CompactionStrategyConfig
  compactTable_args() = (o=new(); fillunset(o); o)
end # type compactTable_args

type compactTable_result
  ouch1::AccumuloSecurityException
  ouch2::TableNotFoundException
  ouch3::AccumuloException
  compactTable_result() = (o=new(); fillunset(o); o)
end # type compactTable_result
meta(t::Type{compactTable_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method cancelCompaction

type cancelCompaction_args
  login::Vector{UInt8}
  tableName::UTF8String
  cancelCompaction_args() = (o=new(); fillunset(o); o)
end # type cancelCompaction_args

type cancelCompaction_result
  ouch1::AccumuloSecurityException
  ouch2::TableNotFoundException
  ouch3::AccumuloException
  cancelCompaction_result() = (o=new(); fillunset(o); o)
end # type cancelCompaction_result
meta(t::Type{cancelCompaction_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method createTable

type createTable_args
  login::Vector{UInt8}
  tableName::UTF8String
  versioningIter::Bool
  _type::Int32
  createTable_args() = (o=new(); fillunset(o); o)
end # type createTable_args

type createTable_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableExistsException
  createTable_result() = (o=new(); fillunset(o); o)
end # type createTable_result
meta(t::Type{createTable_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method deleteTable

type deleteTable_args
  login::Vector{UInt8}
  tableName::UTF8String
  deleteTable_args() = (o=new(); fillunset(o); o)
end # type deleteTable_args

type deleteTable_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  deleteTable_result() = (o=new(); fillunset(o); o)
end # type deleteTable_result
meta(t::Type{deleteTable_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method deleteRows

type deleteRows_args
  login::Vector{UInt8}
  tableName::UTF8String
  startRow::Vector{UInt8}
  endRow::Vector{UInt8}
  deleteRows_args() = (o=new(); fillunset(o); o)
end # type deleteRows_args

type deleteRows_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  deleteRows_result() = (o=new(); fillunset(o); o)
end # type deleteRows_result
meta(t::Type{deleteRows_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method exportTable

type exportTable_args
  login::Vector{UInt8}
  tableName::UTF8String
  exportDir::UTF8String
  exportTable_args() = (o=new(); fillunset(o); o)
end # type exportTable_args

type exportTable_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  exportTable_result() = (o=new(); fillunset(o); o)
end # type exportTable_result
meta(t::Type{exportTable_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method flushTable

type flushTable_args
  login::Vector{UInt8}
  tableName::UTF8String
  startRow::Vector{UInt8}
  endRow::Vector{UInt8}
  wait::Bool
  flushTable_args() = (o=new(); fillunset(o); o)
end # type flushTable_args

type flushTable_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  flushTable_result() = (o=new(); fillunset(o); o)
end # type flushTable_result
meta(t::Type{flushTable_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getDiskUsage

type getDiskUsage_args
  login::Vector{UInt8}
  tables::Set{UTF8String}
  getDiskUsage_args() = (o=new(); fillunset(o); o)
end # type getDiskUsage_args

type getDiskUsage_result
  success::Vector{DiskUsage}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  getDiskUsage_result() = (o=new(); fillunset(o); o)
  getDiskUsage_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getDiskUsage_result
meta(t::Type{getDiskUsage_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getLocalityGroups

type getLocalityGroups_args
  login::Vector{UInt8}
  tableName::UTF8String
  getLocalityGroups_args() = (o=new(); fillunset(o); o)
end # type getLocalityGroups_args

type getLocalityGroups_result
  success::Dict{UTF8String,Set{UTF8String}}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  getLocalityGroups_result() = (o=new(); fillunset(o); o)
  getLocalityGroups_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getLocalityGroups_result
meta(t::Type{getLocalityGroups_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getIteratorSetting

type getIteratorSetting_args
  login::Vector{UInt8}
  tableName::UTF8String
  iteratorName::UTF8String
  scope::Int32
  getIteratorSetting_args() = (o=new(); fillunset(o); o)
end # type getIteratorSetting_args

type getIteratorSetting_result
  success::IteratorSetting
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  getIteratorSetting_result() = (o=new(); fillunset(o); o)
  getIteratorSetting_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getIteratorSetting_result
meta(t::Type{getIteratorSetting_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getMaxRow

type getMaxRow_args
  login::Vector{UInt8}
  tableName::UTF8String
  auths::Set{Vector{UInt8}}
  startRow::Vector{UInt8}
  startInclusive::Bool
  endRow::Vector{UInt8}
  endInclusive::Bool
  getMaxRow_args() = (o=new(); fillunset(o); o)
end # type getMaxRow_args

type getMaxRow_result
  success::Vector{UInt8}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  getMaxRow_result() = (o=new(); fillunset(o); o)
  getMaxRow_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getMaxRow_result
meta(t::Type{getMaxRow_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getTableProperties

type getTableProperties_args
  login::Vector{UInt8}
  tableName::UTF8String
  getTableProperties_args() = (o=new(); fillunset(o); o)
end # type getTableProperties_args

type getTableProperties_result
  success::Dict{UTF8String,UTF8String}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  getTableProperties_result() = (o=new(); fillunset(o); o)
  getTableProperties_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getTableProperties_result
meta(t::Type{getTableProperties_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method importDirectory

type importDirectory_args
  login::Vector{UInt8}
  tableName::UTF8String
  importDir::UTF8String
  failureDir::UTF8String
  setTime::Bool
  importDirectory_args() = (o=new(); fillunset(o); o)
end # type importDirectory_args

type importDirectory_result
  ouch1::TableNotFoundException
  ouch3::AccumuloException
  ouch4::AccumuloSecurityException
  importDirectory_result() = (o=new(); fillunset(o); o)
end # type importDirectory_result
meta(t::Type{importDirectory_result}) = meta(t, Symbol[:ouch1, :ouch3, :ouch4], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method importTable

type importTable_args
  login::Vector{UInt8}
  tableName::UTF8String
  importDir::UTF8String
  importTable_args() = (o=new(); fillunset(o); o)
end # type importTable_args

type importTable_result
  ouch1::TableExistsException
  ouch2::AccumuloException
  ouch3::AccumuloSecurityException
  importTable_result() = (o=new(); fillunset(o); o)
end # type importTable_result
meta(t::Type{importTable_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method listSplits

type listSplits_args
  login::Vector{UInt8}
  tableName::UTF8String
  maxSplits::Int32
  listSplits_args() = (o=new(); fillunset(o); o)
end # type listSplits_args

type listSplits_result
  success::Vector{Vector{UInt8}}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  listSplits_result() = (o=new(); fillunset(o); o)
  listSplits_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type listSplits_result
meta(t::Type{listSplits_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method listTables

type listTables_args
  login::Vector{UInt8}
  listTables_args() = (o=new(); fillunset(o); o)
end # type listTables_args

type listTables_result
  success::Set{UTF8String}
  listTables_result() = (o=new(); fillunset(o); o)
  listTables_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type listTables_result
meta(t::Type{listTables_result}) = meta(t, Symbol[:success], Int[0], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method listIterators

type listIterators_args
  login::Vector{UInt8}
  tableName::UTF8String
  listIterators_args() = (o=new(); fillunset(o); o)
end # type listIterators_args

type listIterators_result
  success::Dict{UTF8String,Set{Int32}}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  listIterators_result() = (o=new(); fillunset(o); o)
  listIterators_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type listIterators_result
meta(t::Type{listIterators_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method listConstraints

type listConstraints_args
  login::Vector{UInt8}
  tableName::UTF8String
  listConstraints_args() = (o=new(); fillunset(o); o)
end # type listConstraints_args

type listConstraints_result
  success::Dict{UTF8String,Int32}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  listConstraints_result() = (o=new(); fillunset(o); o)
  listConstraints_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type listConstraints_result
meta(t::Type{listConstraints_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method mergeTablets

type mergeTablets_args
  login::Vector{UInt8}
  tableName::UTF8String
  startRow::Vector{UInt8}
  endRow::Vector{UInt8}
  mergeTablets_args() = (o=new(); fillunset(o); o)
end # type mergeTablets_args

type mergeTablets_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  mergeTablets_result() = (o=new(); fillunset(o); o)
end # type mergeTablets_result
meta(t::Type{mergeTablets_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method offlineTable

type offlineTable_args
  login::Vector{UInt8}
  tableName::UTF8String
  wait::Bool
  offlineTable_args() = (o=new(); fillunset(o); o)
end # type offlineTable_args
meta(t::Type{offlineTable_args}) = meta(t, Symbol[], Int[], Dict{Symbol,Any}(:wait => false))

type offlineTable_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  offlineTable_result() = (o=new(); fillunset(o); o)
end # type offlineTable_result
meta(t::Type{offlineTable_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method onlineTable

type onlineTable_args
  login::Vector{UInt8}
  tableName::UTF8String
  wait::Bool
  onlineTable_args() = (o=new(); fillunset(o); o)
end # type onlineTable_args
meta(t::Type{onlineTable_args}) = meta(t, Symbol[], Int[], Dict{Symbol,Any}(:wait => false))

type onlineTable_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  onlineTable_result() = (o=new(); fillunset(o); o)
end # type onlineTable_result
meta(t::Type{onlineTable_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method removeConstraint

type removeConstraint_args
  login::Vector{UInt8}
  tableName::UTF8String
  constraint::Int32
  removeConstraint_args() = (o=new(); fillunset(o); o)
end # type removeConstraint_args

type removeConstraint_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  removeConstraint_result() = (o=new(); fillunset(o); o)
end # type removeConstraint_result
meta(t::Type{removeConstraint_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method removeIterator

type removeIterator_args
  login::Vector{UInt8}
  tableName::UTF8String
  iterName::UTF8String
  scopes::Set{Int32}
  removeIterator_args() = (o=new(); fillunset(o); o)
end # type removeIterator_args

type removeIterator_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  removeIterator_result() = (o=new(); fillunset(o); o)
end # type removeIterator_result
meta(t::Type{removeIterator_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method removeTableProperty

type removeTableProperty_args
  login::Vector{UInt8}
  tableName::UTF8String
  property::UTF8String
  removeTableProperty_args() = (o=new(); fillunset(o); o)
end # type removeTableProperty_args

type removeTableProperty_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  removeTableProperty_result() = (o=new(); fillunset(o); o)
end # type removeTableProperty_result
meta(t::Type{removeTableProperty_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method renameTable

type renameTable_args
  login::Vector{UInt8}
  oldTableName::UTF8String
  newTableName::UTF8String
  renameTable_args() = (o=new(); fillunset(o); o)
end # type renameTable_args

type renameTable_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  ouch4::TableExistsException
  renameTable_result() = (o=new(); fillunset(o); o)
end # type renameTable_result
meta(t::Type{renameTable_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3, :ouch4], Int[1, 2, 3, 4], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method setLocalityGroups

type setLocalityGroups_args
  login::Vector{UInt8}
  tableName::UTF8String
  groups::Dict{UTF8String,Set{UTF8String}}
  setLocalityGroups_args() = (o=new(); fillunset(o); o)
end # type setLocalityGroups_args

type setLocalityGroups_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  setLocalityGroups_result() = (o=new(); fillunset(o); o)
end # type setLocalityGroups_result
meta(t::Type{setLocalityGroups_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method setTableProperty

type setTableProperty_args
  login::Vector{UInt8}
  tableName::UTF8String
  property::UTF8String
  value::UTF8String
  setTableProperty_args() = (o=new(); fillunset(o); o)
end # type setTableProperty_args

type setTableProperty_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  setTableProperty_result() = (o=new(); fillunset(o); o)
end # type setTableProperty_result
meta(t::Type{setTableProperty_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method splitRangeByTablets

type splitRangeByTablets_args
  login::Vector{UInt8}
  tableName::UTF8String
  range::Range
  maxSplits::Int32
  splitRangeByTablets_args() = (o=new(); fillunset(o); o)
end # type splitRangeByTablets_args

type splitRangeByTablets_result
  success::Set{Range}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  splitRangeByTablets_result() = (o=new(); fillunset(o); o)
  splitRangeByTablets_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type splitRangeByTablets_result
meta(t::Type{splitRangeByTablets_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method tableExists

type tableExists_args
  login::Vector{UInt8}
  tableName::UTF8String
  tableExists_args() = (o=new(); fillunset(o); o)
end # type tableExists_args

type tableExists_result
  success::Bool
  tableExists_result() = (o=new(); fillunset(o); o)
  tableExists_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type tableExists_result
meta(t::Type{tableExists_result}) = meta(t, Symbol[:success], Int[0], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method tableIdMap

type tableIdMap_args
  login::Vector{UInt8}
  tableIdMap_args() = (o=new(); fillunset(o); o)
end # type tableIdMap_args

type tableIdMap_result
  success::Dict{UTF8String,UTF8String}
  tableIdMap_result() = (o=new(); fillunset(o); o)
  tableIdMap_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type tableIdMap_result
meta(t::Type{tableIdMap_result}) = meta(t, Symbol[:success], Int[0], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method testTableClassLoad

type testTableClassLoad_args
  login::Vector{UInt8}
  tableName::UTF8String
  className::UTF8String
  asTypeName::UTF8String
  testTableClassLoad_args() = (o=new(); fillunset(o); o)
end # type testTableClassLoad_args

type testTableClassLoad_result
  success::Bool
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  testTableClassLoad_result() = (o=new(); fillunset(o); o)
  testTableClassLoad_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type testTableClassLoad_result
meta(t::Type{testTableClassLoad_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method pingTabletServer

type pingTabletServer_args
  login::Vector{UInt8}
  tserver::UTF8String
  pingTabletServer_args() = (o=new(); fillunset(o); o)
end # type pingTabletServer_args

type pingTabletServer_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  pingTabletServer_result() = (o=new(); fillunset(o); o)
end # type pingTabletServer_result
meta(t::Type{pingTabletServer_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getActiveScans

type getActiveScans_args
  login::Vector{UInt8}
  tserver::UTF8String
  getActiveScans_args() = (o=new(); fillunset(o); o)
end # type getActiveScans_args

type getActiveScans_result
  success::Vector{ActiveScan}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  getActiveScans_result() = (o=new(); fillunset(o); o)
  getActiveScans_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getActiveScans_result
meta(t::Type{getActiveScans_result}) = meta(t, Symbol[:success, :ouch1, :ouch2], Int[0, 1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getActiveCompactions

type getActiveCompactions_args
  login::Vector{UInt8}
  tserver::UTF8String
  getActiveCompactions_args() = (o=new(); fillunset(o); o)
end # type getActiveCompactions_args

type getActiveCompactions_result
  success::Vector{ActiveCompaction}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  getActiveCompactions_result() = (o=new(); fillunset(o); o)
  getActiveCompactions_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getActiveCompactions_result
meta(t::Type{getActiveCompactions_result}) = meta(t, Symbol[:success, :ouch1, :ouch2], Int[0, 1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getSiteConfiguration

type getSiteConfiguration_args
  login::Vector{UInt8}
  getSiteConfiguration_args() = (o=new(); fillunset(o); o)
end # type getSiteConfiguration_args

type getSiteConfiguration_result
  success::Dict{UTF8String,UTF8String}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  getSiteConfiguration_result() = (o=new(); fillunset(o); o)
  getSiteConfiguration_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getSiteConfiguration_result
meta(t::Type{getSiteConfiguration_result}) = meta(t, Symbol[:success, :ouch1, :ouch2], Int[0, 1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getSystemConfiguration

type getSystemConfiguration_args
  login::Vector{UInt8}
  getSystemConfiguration_args() = (o=new(); fillunset(o); o)
end # type getSystemConfiguration_args

type getSystemConfiguration_result
  success::Dict{UTF8String,UTF8String}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  getSystemConfiguration_result() = (o=new(); fillunset(o); o)
  getSystemConfiguration_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getSystemConfiguration_result
meta(t::Type{getSystemConfiguration_result}) = meta(t, Symbol[:success, :ouch1, :ouch2], Int[0, 1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getTabletServers

type getTabletServers_args
  login::Vector{UInt8}
  getTabletServers_args() = (o=new(); fillunset(o); o)
end # type getTabletServers_args

type getTabletServers_result
  success::Vector{UTF8String}
  getTabletServers_result() = (o=new(); fillunset(o); o)
  getTabletServers_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getTabletServers_result
meta(t::Type{getTabletServers_result}) = meta(t, Symbol[:success], Int[0], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method removeProperty

type removeProperty_args
  login::Vector{UInt8}
  property::UTF8String
  removeProperty_args() = (o=new(); fillunset(o); o)
end # type removeProperty_args

type removeProperty_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  removeProperty_result() = (o=new(); fillunset(o); o)
end # type removeProperty_result
meta(t::Type{removeProperty_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method setProperty

type setProperty_args
  login::Vector{UInt8}
  property::UTF8String
  value::UTF8String
  setProperty_args() = (o=new(); fillunset(o); o)
end # type setProperty_args

type setProperty_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  setProperty_result() = (o=new(); fillunset(o); o)
end # type setProperty_result
meta(t::Type{setProperty_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method testClassLoad

type testClassLoad_args
  login::Vector{UInt8}
  className::UTF8String
  asTypeName::UTF8String
  testClassLoad_args() = (o=new(); fillunset(o); o)
end # type testClassLoad_args

type testClassLoad_result
  success::Bool
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  testClassLoad_result() = (o=new(); fillunset(o); o)
  testClassLoad_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type testClassLoad_result
meta(t::Type{testClassLoad_result}) = meta(t, Symbol[:success, :ouch1, :ouch2], Int[0, 1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method authenticateUser

type authenticateUser_args
  login::Vector{UInt8}
  user::UTF8String
  properties::Dict{UTF8String,UTF8String}
  authenticateUser_args() = (o=new(); fillunset(o); o)
end # type authenticateUser_args

type authenticateUser_result
  success::Bool
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  authenticateUser_result() = (o=new(); fillunset(o); o)
  authenticateUser_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type authenticateUser_result
meta(t::Type{authenticateUser_result}) = meta(t, Symbol[:success, :ouch1, :ouch2], Int[0, 1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method changeUserAuthorizations

type changeUserAuthorizations_args
  login::Vector{UInt8}
  user::UTF8String
  authorizations::Set{Vector{UInt8}}
  changeUserAuthorizations_args() = (o=new(); fillunset(o); o)
end # type changeUserAuthorizations_args

type changeUserAuthorizations_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  changeUserAuthorizations_result() = (o=new(); fillunset(o); o)
end # type changeUserAuthorizations_result
meta(t::Type{changeUserAuthorizations_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method changeLocalUserPassword

type changeLocalUserPassword_args
  login::Vector{UInt8}
  user::UTF8String
  password::Vector{UInt8}
  changeLocalUserPassword_args() = (o=new(); fillunset(o); o)
end # type changeLocalUserPassword_args

type changeLocalUserPassword_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  changeLocalUserPassword_result() = (o=new(); fillunset(o); o)
end # type changeLocalUserPassword_result
meta(t::Type{changeLocalUserPassword_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method createLocalUser

type createLocalUser_args
  login::Vector{UInt8}
  user::UTF8String
  password::Vector{UInt8}
  createLocalUser_args() = (o=new(); fillunset(o); o)
end # type createLocalUser_args

type createLocalUser_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  createLocalUser_result() = (o=new(); fillunset(o); o)
end # type createLocalUser_result
meta(t::Type{createLocalUser_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method dropLocalUser

type dropLocalUser_args
  login::Vector{UInt8}
  user::UTF8String
  dropLocalUser_args() = (o=new(); fillunset(o); o)
end # type dropLocalUser_args

type dropLocalUser_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  dropLocalUser_result() = (o=new(); fillunset(o); o)
end # type dropLocalUser_result
meta(t::Type{dropLocalUser_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getUserAuthorizations

type getUserAuthorizations_args
  login::Vector{UInt8}
  user::UTF8String
  getUserAuthorizations_args() = (o=new(); fillunset(o); o)
end # type getUserAuthorizations_args

type getUserAuthorizations_result
  success::Vector{Vector{UInt8}}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  getUserAuthorizations_result() = (o=new(); fillunset(o); o)
  getUserAuthorizations_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getUserAuthorizations_result
meta(t::Type{getUserAuthorizations_result}) = meta(t, Symbol[:success, :ouch1, :ouch2], Int[0, 1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method grantSystemPermission

type grantSystemPermission_args
  login::Vector{UInt8}
  user::UTF8String
  perm::Int32
  grantSystemPermission_args() = (o=new(); fillunset(o); o)
end # type grantSystemPermission_args

type grantSystemPermission_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  grantSystemPermission_result() = (o=new(); fillunset(o); o)
end # type grantSystemPermission_result
meta(t::Type{grantSystemPermission_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method grantTablePermission

type grantTablePermission_args
  login::Vector{UInt8}
  user::UTF8String
  table::UTF8String
  perm::Int32
  grantTablePermission_args() = (o=new(); fillunset(o); o)
end # type grantTablePermission_args

type grantTablePermission_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  grantTablePermission_result() = (o=new(); fillunset(o); o)
end # type grantTablePermission_result
meta(t::Type{grantTablePermission_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method hasSystemPermission

type hasSystemPermission_args
  login::Vector{UInt8}
  user::UTF8String
  perm::Int32
  hasSystemPermission_args() = (o=new(); fillunset(o); o)
end # type hasSystemPermission_args

type hasSystemPermission_result
  success::Bool
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  hasSystemPermission_result() = (o=new(); fillunset(o); o)
  hasSystemPermission_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type hasSystemPermission_result
meta(t::Type{hasSystemPermission_result}) = meta(t, Symbol[:success, :ouch1, :ouch2], Int[0, 1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method hasTablePermission

type hasTablePermission_args
  login::Vector{UInt8}
  user::UTF8String
  table::UTF8String
  perm::Int32
  hasTablePermission_args() = (o=new(); fillunset(o); o)
end # type hasTablePermission_args

type hasTablePermission_result
  success::Bool
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  hasTablePermission_result() = (o=new(); fillunset(o); o)
  hasTablePermission_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type hasTablePermission_result
meta(t::Type{hasTablePermission_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method listLocalUsers

type listLocalUsers_args
  login::Vector{UInt8}
  listLocalUsers_args() = (o=new(); fillunset(o); o)
end # type listLocalUsers_args

type listLocalUsers_result
  success::Set{UTF8String}
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  listLocalUsers_result() = (o=new(); fillunset(o); o)
  listLocalUsers_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type listLocalUsers_result
meta(t::Type{listLocalUsers_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method revokeSystemPermission

type revokeSystemPermission_args
  login::Vector{UInt8}
  user::UTF8String
  perm::Int32
  revokeSystemPermission_args() = (o=new(); fillunset(o); o)
end # type revokeSystemPermission_args

type revokeSystemPermission_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  revokeSystemPermission_result() = (o=new(); fillunset(o); o)
end # type revokeSystemPermission_result
meta(t::Type{revokeSystemPermission_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method revokeTablePermission

type revokeTablePermission_args
  login::Vector{UInt8}
  user::UTF8String
  table::UTF8String
  perm::Int32
  revokeTablePermission_args() = (o=new(); fillunset(o); o)
end # type revokeTablePermission_args

type revokeTablePermission_result
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  revokeTablePermission_result() = (o=new(); fillunset(o); o)
end # type revokeTablePermission_result
meta(t::Type{revokeTablePermission_result}) = meta(t, Symbol[:ouch1, :ouch2, :ouch3], Int[1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method createBatchScanner

type createBatchScanner_args
  login::Vector{UInt8}
  tableName::UTF8String
  options::BatchScanOptions
  createBatchScanner_args() = (o=new(); fillunset(o); o)
end # type createBatchScanner_args

type createBatchScanner_result
  success::UTF8String
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  createBatchScanner_result() = (o=new(); fillunset(o); o)
  createBatchScanner_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type createBatchScanner_result
meta(t::Type{createBatchScanner_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method createScanner

type createScanner_args
  login::Vector{UInt8}
  tableName::UTF8String
  options::ScanOptions
  createScanner_args() = (o=new(); fillunset(o); o)
end # type createScanner_args

type createScanner_result
  success::UTF8String
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  createScanner_result() = (o=new(); fillunset(o); o)
  createScanner_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type createScanner_result
meta(t::Type{createScanner_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method hasNext

type hasNext_args
  scanner::UTF8String
  hasNext_args() = (o=new(); fillunset(o); o)
end # type hasNext_args

type hasNext_result
  success::Bool
  ouch1::UnknownScanner
  hasNext_result() = (o=new(); fillunset(o); o)
  hasNext_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type hasNext_result
meta(t::Type{hasNext_result}) = meta(t, Symbol[:success, :ouch1], Int[0, 1], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method nextEntry

type nextEntry_args
  scanner::UTF8String
  nextEntry_args() = (o=new(); fillunset(o); o)
end # type nextEntry_args

type nextEntry_result
  success::KeyValueAndPeek
  ouch1::NoMoreEntriesException
  ouch2::UnknownScanner
  ouch3::AccumuloSecurityException
  nextEntry_result() = (o=new(); fillunset(o); o)
  nextEntry_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type nextEntry_result
meta(t::Type{nextEntry_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method nextK

type nextK_args
  scanner::UTF8String
  k::Int32
  nextK_args() = (o=new(); fillunset(o); o)
end # type nextK_args

type nextK_result
  success::ScanResult
  ouch1::NoMoreEntriesException
  ouch2::UnknownScanner
  ouch3::AccumuloSecurityException
  nextK_result() = (o=new(); fillunset(o); o)
  nextK_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type nextK_result
meta(t::Type{nextK_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method closeScanner

type closeScanner_args
  scanner::UTF8String
  closeScanner_args() = (o=new(); fillunset(o); o)
end # type closeScanner_args

type closeScanner_result
  ouch1::UnknownScanner
  closeScanner_result() = (o=new(); fillunset(o); o)
end # type closeScanner_result
meta(t::Type{closeScanner_result}) = meta(t, Symbol[:ouch1], Int[1], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method updateAndFlush

type updateAndFlush_args
  login::Vector{UInt8}
  tableName::UTF8String
  cells::Dict{Vector{UInt8},Vector{ColumnUpdate}}
  updateAndFlush_args() = (o=new(); fillunset(o); o)
end # type updateAndFlush_args

type updateAndFlush_result
  outch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  ouch4::MutationsRejectedException
  updateAndFlush_result() = (o=new(); fillunset(o); o)
end # type updateAndFlush_result
meta(t::Type{updateAndFlush_result}) = meta(t, Symbol[:outch1, :ouch2, :ouch3, :ouch4], Int[1, 2, 3, 4], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method createWriter

type createWriter_args
  login::Vector{UInt8}
  tableName::UTF8String
  opts::WriterOptions
  createWriter_args() = (o=new(); fillunset(o); o)
end # type createWriter_args

type createWriter_result
  success::UTF8String
  outch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  createWriter_result() = (o=new(); fillunset(o); o)
  createWriter_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type createWriter_result
meta(t::Type{createWriter_result}) = meta(t, Symbol[:success, :outch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method update

type update_args
  writer::UTF8String
  cells::Dict{Vector{UInt8},Vector{ColumnUpdate}}
  update_args() = (o=new(); fillunset(o); o)
end # type update_args

type update_result
end # type update_result
meta(t::Type{update_result}) = meta(t, Symbol[], Int[], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method flush

type flush_args
  writer::UTF8String
  flush_args() = (o=new(); fillunset(o); o)
end # type flush_args

type flush_result
  ouch1::UnknownWriter
  ouch2::MutationsRejectedException
  flush_result() = (o=new(); fillunset(o); o)
end # type flush_result
meta(t::Type{flush_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method closeWriter

type closeWriter_args
  writer::UTF8String
  closeWriter_args() = (o=new(); fillunset(o); o)
end # type closeWriter_args

type closeWriter_result
  ouch1::UnknownWriter
  ouch2::MutationsRejectedException
  closeWriter_result() = (o=new(); fillunset(o); o)
end # type closeWriter_result
meta(t::Type{closeWriter_result}) = meta(t, Symbol[:ouch1, :ouch2], Int[1, 2], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method updateRowConditionally

type updateRowConditionally_args
  login::Vector{UInt8}
  tableName::UTF8String
  row::Vector{UInt8}
  updates::ConditionalUpdates
  updateRowConditionally_args() = (o=new(); fillunset(o); o)
end # type updateRowConditionally_args

type updateRowConditionally_result
  success::Int32
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  updateRowConditionally_result() = (o=new(); fillunset(o); o)
  updateRowConditionally_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type updateRowConditionally_result
meta(t::Type{updateRowConditionally_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method createConditionalWriter

type createConditionalWriter_args
  login::Vector{UInt8}
  tableName::UTF8String
  options::ConditionalWriterOptions
  createConditionalWriter_args() = (o=new(); fillunset(o); o)
end # type createConditionalWriter_args

type createConditionalWriter_result
  success::UTF8String
  ouch1::AccumuloException
  ouch2::AccumuloSecurityException
  ouch3::TableNotFoundException
  createConditionalWriter_result() = (o=new(); fillunset(o); o)
  createConditionalWriter_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type createConditionalWriter_result
meta(t::Type{createConditionalWriter_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method updateRowsConditionally

type updateRowsConditionally_args
  conditionalWriter::UTF8String
  updates::Dict{Vector{UInt8},ConditionalUpdates}
  updateRowsConditionally_args() = (o=new(); fillunset(o); o)
end # type updateRowsConditionally_args

type updateRowsConditionally_result
  success::Dict{Vector{UInt8},Int32}
  ouch1::UnknownWriter
  ouch2::AccumuloException
  ouch3::AccumuloSecurityException
  updateRowsConditionally_result() = (o=new(); fillunset(o); o)
  updateRowsConditionally_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type updateRowsConditionally_result
meta(t::Type{updateRowsConditionally_result}) = meta(t, Symbol[:success, :ouch1, :ouch2, :ouch3], Int[0, 1, 2, 3], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method closeConditionalWriter

type closeConditionalWriter_args
  conditionalWriter::UTF8String
  closeConditionalWriter_args() = (o=new(); fillunset(o); o)
end # type closeConditionalWriter_args

type closeConditionalWriter_result
end # type closeConditionalWriter_result
meta(t::Type{closeConditionalWriter_result}) = meta(t, Symbol[], Int[], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getRowRange

type getRowRange_args
  row::Vector{UInt8}
  getRowRange_args() = (o=new(); fillunset(o); o)
end # type getRowRange_args

type getRowRange_result
  success::Range
  getRowRange_result() = (o=new(); fillunset(o); o)
  getRowRange_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getRowRange_result
meta(t::Type{getRowRange_result}) = meta(t, Symbol[:success], Int[0], Dict{Symbol,Any}())

# types encapsulating arguments and return values of method getFollowing

type getFollowing_args
  key::Key
  part::Int32
  getFollowing_args() = (o=new(); fillunset(o); o)
end # type getFollowing_args

type getFollowing_result
  success::Key
  getFollowing_result() = (o=new(); fillunset(o); o)
  getFollowing_result(success) = (o=new(); fillset(o, :success); o.success=success; o)
end # type getFollowing_result
meta(t::Type{getFollowing_result}) = meta(t, Symbol[:success], Int[0], Dict{Symbol,Any}())



# Processor for AccumuloProxy service (to be used in server implementation)
type AccumuloProxyProcessor <: TProcessor
  tp::ThriftProcessor
  function AccumuloProxyProcessor()
    p = new(ThriftProcessor())
    handle(p.tp, ThriftHandler("login", _login, login_args, login_result))
    handle(p.tp, ThriftHandler("addConstraint", _addConstraint, addConstraint_args, addConstraint_result))
    handle(p.tp, ThriftHandler("addSplits", _addSplits, addSplits_args, addSplits_result))
    handle(p.tp, ThriftHandler("attachIterator", _attachIterator, attachIterator_args, attachIterator_result))
    handle(p.tp, ThriftHandler("checkIteratorConflicts", _checkIteratorConflicts, checkIteratorConflicts_args, checkIteratorConflicts_result))
    handle(p.tp, ThriftHandler("clearLocatorCache", _clearLocatorCache, clearLocatorCache_args, clearLocatorCache_result))
    handle(p.tp, ThriftHandler("cloneTable", _cloneTable, cloneTable_args, cloneTable_result))
    handle(p.tp, ThriftHandler("compactTable", _compactTable, compactTable_args, compactTable_result))
    handle(p.tp, ThriftHandler("cancelCompaction", _cancelCompaction, cancelCompaction_args, cancelCompaction_result))
    handle(p.tp, ThriftHandler("createTable", _createTable, createTable_args, createTable_result))
    handle(p.tp, ThriftHandler("deleteTable", _deleteTable, deleteTable_args, deleteTable_result))
    handle(p.tp, ThriftHandler("deleteRows", _deleteRows, deleteRows_args, deleteRows_result))
    handle(p.tp, ThriftHandler("exportTable", _exportTable, exportTable_args, exportTable_result))
    handle(p.tp, ThriftHandler("flushTable", _flushTable, flushTable_args, flushTable_result))
    handle(p.tp, ThriftHandler("getDiskUsage", _getDiskUsage, getDiskUsage_args, getDiskUsage_result))
    handle(p.tp, ThriftHandler("getLocalityGroups", _getLocalityGroups, getLocalityGroups_args, getLocalityGroups_result))
    handle(p.tp, ThriftHandler("getIteratorSetting", _getIteratorSetting, getIteratorSetting_args, getIteratorSetting_result))
    handle(p.tp, ThriftHandler("getMaxRow", _getMaxRow, getMaxRow_args, getMaxRow_result))
    handle(p.tp, ThriftHandler("getTableProperties", _getTableProperties, getTableProperties_args, getTableProperties_result))
    handle(p.tp, ThriftHandler("importDirectory", _importDirectory, importDirectory_args, importDirectory_result))
    handle(p.tp, ThriftHandler("importTable", _importTable, importTable_args, importTable_result))
    handle(p.tp, ThriftHandler("listSplits", _listSplits, listSplits_args, listSplits_result))
    handle(p.tp, ThriftHandler("listTables", _listTables, listTables_args, listTables_result))
    handle(p.tp, ThriftHandler("listIterators", _listIterators, listIterators_args, listIterators_result))
    handle(p.tp, ThriftHandler("listConstraints", _listConstraints, listConstraints_args, listConstraints_result))
    handle(p.tp, ThriftHandler("mergeTablets", _mergeTablets, mergeTablets_args, mergeTablets_result))
    handle(p.tp, ThriftHandler("offlineTable", _offlineTable, offlineTable_args, offlineTable_result))
    handle(p.tp, ThriftHandler("onlineTable", _onlineTable, onlineTable_args, onlineTable_result))
    handle(p.tp, ThriftHandler("removeConstraint", _removeConstraint, removeConstraint_args, removeConstraint_result))
    handle(p.tp, ThriftHandler("removeIterator", _removeIterator, removeIterator_args, removeIterator_result))
    handle(p.tp, ThriftHandler("removeTableProperty", _removeTableProperty, removeTableProperty_args, removeTableProperty_result))
    handle(p.tp, ThriftHandler("renameTable", _renameTable, renameTable_args, renameTable_result))
    handle(p.tp, ThriftHandler("setLocalityGroups", _setLocalityGroups, setLocalityGroups_args, setLocalityGroups_result))
    handle(p.tp, ThriftHandler("setTableProperty", _setTableProperty, setTableProperty_args, setTableProperty_result))
    handle(p.tp, ThriftHandler("splitRangeByTablets", _splitRangeByTablets, splitRangeByTablets_args, splitRangeByTablets_result))
    handle(p.tp, ThriftHandler("tableExists", _tableExists, tableExists_args, tableExists_result))
    handle(p.tp, ThriftHandler("tableIdMap", _tableIdMap, tableIdMap_args, tableIdMap_result))
    handle(p.tp, ThriftHandler("testTableClassLoad", _testTableClassLoad, testTableClassLoad_args, testTableClassLoad_result))
    handle(p.tp, ThriftHandler("pingTabletServer", _pingTabletServer, pingTabletServer_args, pingTabletServer_result))
    handle(p.tp, ThriftHandler("getActiveScans", _getActiveScans, getActiveScans_args, getActiveScans_result))
    handle(p.tp, ThriftHandler("getActiveCompactions", _getActiveCompactions, getActiveCompactions_args, getActiveCompactions_result))
    handle(p.tp, ThriftHandler("getSiteConfiguration", _getSiteConfiguration, getSiteConfiguration_args, getSiteConfiguration_result))
    handle(p.tp, ThriftHandler("getSystemConfiguration", _getSystemConfiguration, getSystemConfiguration_args, getSystemConfiguration_result))
    handle(p.tp, ThriftHandler("getTabletServers", _getTabletServers, getTabletServers_args, getTabletServers_result))
    handle(p.tp, ThriftHandler("removeProperty", _removeProperty, removeProperty_args, removeProperty_result))
    handle(p.tp, ThriftHandler("setProperty", _setProperty, setProperty_args, setProperty_result))
    handle(p.tp, ThriftHandler("testClassLoad", _testClassLoad, testClassLoad_args, testClassLoad_result))
    handle(p.tp, ThriftHandler("authenticateUser", _authenticateUser, authenticateUser_args, authenticateUser_result))
    handle(p.tp, ThriftHandler("changeUserAuthorizations", _changeUserAuthorizations, changeUserAuthorizations_args, changeUserAuthorizations_result))
    handle(p.tp, ThriftHandler("changeLocalUserPassword", _changeLocalUserPassword, changeLocalUserPassword_args, changeLocalUserPassword_result))
    handle(p.tp, ThriftHandler("createLocalUser", _createLocalUser, createLocalUser_args, createLocalUser_result))
    handle(p.tp, ThriftHandler("dropLocalUser", _dropLocalUser, dropLocalUser_args, dropLocalUser_result))
    handle(p.tp, ThriftHandler("getUserAuthorizations", _getUserAuthorizations, getUserAuthorizations_args, getUserAuthorizations_result))
    handle(p.tp, ThriftHandler("grantSystemPermission", _grantSystemPermission, grantSystemPermission_args, grantSystemPermission_result))
    handle(p.tp, ThriftHandler("grantTablePermission", _grantTablePermission, grantTablePermission_args, grantTablePermission_result))
    handle(p.tp, ThriftHandler("hasSystemPermission", _hasSystemPermission, hasSystemPermission_args, hasSystemPermission_result))
    handle(p.tp, ThriftHandler("hasTablePermission", _hasTablePermission, hasTablePermission_args, hasTablePermission_result))
    handle(p.tp, ThriftHandler("listLocalUsers", _listLocalUsers, listLocalUsers_args, listLocalUsers_result))
    handle(p.tp, ThriftHandler("revokeSystemPermission", _revokeSystemPermission, revokeSystemPermission_args, revokeSystemPermission_result))
    handle(p.tp, ThriftHandler("revokeTablePermission", _revokeTablePermission, revokeTablePermission_args, revokeTablePermission_result))
    handle(p.tp, ThriftHandler("createBatchScanner", _createBatchScanner, createBatchScanner_args, createBatchScanner_result))
    handle(p.tp, ThriftHandler("createScanner", _createScanner, createScanner_args, createScanner_result))
    handle(p.tp, ThriftHandler("hasNext", _hasNext, hasNext_args, hasNext_result))
    handle(p.tp, ThriftHandler("nextEntry", _nextEntry, nextEntry_args, nextEntry_result))
    handle(p.tp, ThriftHandler("nextK", _nextK, nextK_args, nextK_result))
    handle(p.tp, ThriftHandler("closeScanner", _closeScanner, closeScanner_args, closeScanner_result))
    handle(p.tp, ThriftHandler("updateAndFlush", _updateAndFlush, updateAndFlush_args, updateAndFlush_result))
    handle(p.tp, ThriftHandler("createWriter", _createWriter, createWriter_args, createWriter_result))
    handle(p.tp, ThriftHandler("update", _update, update_args, update_result))
    handle(p.tp, ThriftHandler("flush", _flush, flush_args, flush_result))
    handle(p.tp, ThriftHandler("closeWriter", _closeWriter, closeWriter_args, closeWriter_result))
    handle(p.tp, ThriftHandler("updateRowConditionally", _updateRowConditionally, updateRowConditionally_args, updateRowConditionally_result))
    handle(p.tp, ThriftHandler("createConditionalWriter", _createConditionalWriter, createConditionalWriter_args, createConditionalWriter_result))
    handle(p.tp, ThriftHandler("updateRowsConditionally", _updateRowsConditionally, updateRowsConditionally_args, updateRowsConditionally_result))
    handle(p.tp, ThriftHandler("closeConditionalWriter", _closeConditionalWriter, closeConditionalWriter_args, closeConditionalWriter_result))
    handle(p.tp, ThriftHandler("getRowRange", _getRowRange, getRowRange_args, getRowRange_result))
    handle(p.tp, ThriftHandler("getFollowing", _getFollowing, getFollowing_args, getFollowing_result))
    p
  end
  function _login(inp::login_args)
    try
      result = login(inp.principal, inp.loginProperties)
      return login_result(result)
    catch ex
      exret = login_result()
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _login
  function _addConstraint(inp::addConstraint_args)
    try
      result = addConstraint(inp.login, inp.tableName, inp.constraintClassName)
      return addConstraint_result(result)
    catch ex
      exret = addConstraint_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _addConstraint
  function _addSplits(inp::addSplits_args)
    try
      addSplits(inp.login, inp.tableName, inp.splits)
      return addSplits_result()
    catch ex
      exret = addSplits_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _addSplits
  function _attachIterator(inp::attachIterator_args)
    try
      attachIterator(inp.login, inp.tableName, inp.setting, inp.scopes)
      return attachIterator_result()
    catch ex
      exret = attachIterator_result()
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _attachIterator
  function _checkIteratorConflicts(inp::checkIteratorConflicts_args)
    try
      checkIteratorConflicts(inp.login, inp.tableName, inp.setting, inp.scopes)
      return checkIteratorConflicts_result()
    catch ex
      exret = checkIteratorConflicts_result()
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _checkIteratorConflicts
  function _clearLocatorCache(inp::clearLocatorCache_args)
    try
      clearLocatorCache(inp.login, inp.tableName)
      return clearLocatorCache_result()
    catch ex
      exret = clearLocatorCache_result()
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch1, ex); return exret)
      rethrow()
    end # try
  end #function _clearLocatorCache
  function _cloneTable(inp::cloneTable_args)
    try
      cloneTable(inp.login, inp.tableName, inp.newTableName, inp.flush, inp.propertiesToSet, inp.propertiesToExclude)
      return cloneTable_result()
    catch ex
      exret = cloneTable_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      isa(ex, TableExistsException) && (set_field!(exret, :ouch4, ex); return exret)
      rethrow()
    end # try
  end #function _cloneTable
  function _compactTable(inp::compactTable_args)
    try
      compactTable(inp.login, inp.tableName, inp.startRow, inp.endRow, inp.iterators, inp.flush, inp.wait, inp.compactionStrategy)
      return compactTable_result()
    catch ex
      exret = compactTable_result()
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, AccumuloException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _compactTable
  function _cancelCompaction(inp::cancelCompaction_args)
    try
      cancelCompaction(inp.login, inp.tableName)
      return cancelCompaction_result()
    catch ex
      exret = cancelCompaction_result()
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, AccumuloException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _cancelCompaction
  function _createTable(inp::createTable_args)
    try
      createTable(inp.login, inp.tableName, inp.versioningIter, inp._type)
      return createTable_result()
    catch ex
      exret = createTable_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableExistsException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _createTable
  function _deleteTable(inp::deleteTable_args)
    try
      deleteTable(inp.login, inp.tableName)
      return deleteTable_result()
    catch ex
      exret = deleteTable_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _deleteTable
  function _deleteRows(inp::deleteRows_args)
    try
      deleteRows(inp.login, inp.tableName, inp.startRow, inp.endRow)
      return deleteRows_result()
    catch ex
      exret = deleteRows_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _deleteRows
  function _exportTable(inp::exportTable_args)
    try
      exportTable(inp.login, inp.tableName, inp.exportDir)
      return exportTable_result()
    catch ex
      exret = exportTable_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _exportTable
  function _flushTable(inp::flushTable_args)
    try
      flushTable(inp.login, inp.tableName, inp.startRow, inp.endRow, inp.wait)
      return flushTable_result()
    catch ex
      exret = flushTable_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _flushTable
  function _getDiskUsage(inp::getDiskUsage_args)
    try
      result = getDiskUsage(inp.login, inp.tables)
      return getDiskUsage_result(result)
    catch ex
      exret = getDiskUsage_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _getDiskUsage
  function _getLocalityGroups(inp::getLocalityGroups_args)
    try
      result = getLocalityGroups(inp.login, inp.tableName)
      return getLocalityGroups_result(result)
    catch ex
      exret = getLocalityGroups_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _getLocalityGroups
  function _getIteratorSetting(inp::getIteratorSetting_args)
    try
      result = getIteratorSetting(inp.login, inp.tableName, inp.iteratorName, inp.scope)
      return getIteratorSetting_result(result)
    catch ex
      exret = getIteratorSetting_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _getIteratorSetting
  function _getMaxRow(inp::getMaxRow_args)
    try
      result = getMaxRow(inp.login, inp.tableName, inp.auths, inp.startRow, inp.startInclusive, inp.endRow, inp.endInclusive)
      return getMaxRow_result(result)
    catch ex
      exret = getMaxRow_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _getMaxRow
  function _getTableProperties(inp::getTableProperties_args)
    try
      result = getTableProperties(inp.login, inp.tableName)
      return getTableProperties_result(result)
    catch ex
      exret = getTableProperties_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _getTableProperties
  function _importDirectory(inp::importDirectory_args)
    try
      importDirectory(inp.login, inp.tableName, inp.importDir, inp.failureDir, inp.setTime)
      return importDirectory_result()
    catch ex
      exret = importDirectory_result()
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloException) && (set_field!(exret, :ouch3, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch4, ex); return exret)
      rethrow()
    end # try
  end #function _importDirectory
  function _importTable(inp::importTable_args)
    try
      importTable(inp.login, inp.tableName, inp.importDir)
      return importTable_result()
    catch ex
      exret = importTable_result()
      isa(ex, TableExistsException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _importTable
  function _listSplits(inp::listSplits_args)
    try
      result = listSplits(inp.login, inp.tableName, inp.maxSplits)
      return listSplits_result(result)
    catch ex
      exret = listSplits_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _listSplits
  _listTables(inp::listTables_args) = listTables_result(listTables(inp.login))
  function _listIterators(inp::listIterators_args)
    try
      result = listIterators(inp.login, inp.tableName)
      return listIterators_result(result)
    catch ex
      exret = listIterators_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _listIterators
  function _listConstraints(inp::listConstraints_args)
    try
      result = listConstraints(inp.login, inp.tableName)
      return listConstraints_result(result)
    catch ex
      exret = listConstraints_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _listConstraints
  function _mergeTablets(inp::mergeTablets_args)
    try
      mergeTablets(inp.login, inp.tableName, inp.startRow, inp.endRow)
      return mergeTablets_result()
    catch ex
      exret = mergeTablets_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _mergeTablets
  function _offlineTable(inp::offlineTable_args)
    try
      offlineTable(inp.login, inp.tableName, inp.wait)
      return offlineTable_result()
    catch ex
      exret = offlineTable_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _offlineTable
  function _onlineTable(inp::onlineTable_args)
    try
      onlineTable(inp.login, inp.tableName, inp.wait)
      return onlineTable_result()
    catch ex
      exret = onlineTable_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _onlineTable
  function _removeConstraint(inp::removeConstraint_args)
    try
      removeConstraint(inp.login, inp.tableName, inp.constraint)
      return removeConstraint_result()
    catch ex
      exret = removeConstraint_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _removeConstraint
  function _removeIterator(inp::removeIterator_args)
    try
      removeIterator(inp.login, inp.tableName, inp.iterName, inp.scopes)
      return removeIterator_result()
    catch ex
      exret = removeIterator_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _removeIterator
  function _removeTableProperty(inp::removeTableProperty_args)
    try
      removeTableProperty(inp.login, inp.tableName, inp.property)
      return removeTableProperty_result()
    catch ex
      exret = removeTableProperty_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _removeTableProperty
  function _renameTable(inp::renameTable_args)
    try
      renameTable(inp.login, inp.oldTableName, inp.newTableName)
      return renameTable_result()
    catch ex
      exret = renameTable_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      isa(ex, TableExistsException) && (set_field!(exret, :ouch4, ex); return exret)
      rethrow()
    end # try
  end #function _renameTable
  function _setLocalityGroups(inp::setLocalityGroups_args)
    try
      setLocalityGroups(inp.login, inp.tableName, inp.groups)
      return setLocalityGroups_result()
    catch ex
      exret = setLocalityGroups_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _setLocalityGroups
  function _setTableProperty(inp::setTableProperty_args)
    try
      setTableProperty(inp.login, inp.tableName, inp.property, inp.value)
      return setTableProperty_result()
    catch ex
      exret = setTableProperty_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _setTableProperty
  function _splitRangeByTablets(inp::splitRangeByTablets_args)
    try
      result = splitRangeByTablets(inp.login, inp.tableName, inp.range, inp.maxSplits)
      return splitRangeByTablets_result(result)
    catch ex
      exret = splitRangeByTablets_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _splitRangeByTablets
  _tableExists(inp::tableExists_args) = tableExists_result(tableExists(inp.login, inp.tableName))
  _tableIdMap(inp::tableIdMap_args) = tableIdMap_result(tableIdMap(inp.login))
  function _testTableClassLoad(inp::testTableClassLoad_args)
    try
      result = testTableClassLoad(inp.login, inp.tableName, inp.className, inp.asTypeName)
      return testTableClassLoad_result(result)
    catch ex
      exret = testTableClassLoad_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _testTableClassLoad
  function _pingTabletServer(inp::pingTabletServer_args)
    try
      pingTabletServer(inp.login, inp.tserver)
      return pingTabletServer_result()
    catch ex
      exret = pingTabletServer_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _pingTabletServer
  function _getActiveScans(inp::getActiveScans_args)
    try
      result = getActiveScans(inp.login, inp.tserver)
      return getActiveScans_result(result)
    catch ex
      exret = getActiveScans_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _getActiveScans
  function _getActiveCompactions(inp::getActiveCompactions_args)
    try
      result = getActiveCompactions(inp.login, inp.tserver)
      return getActiveCompactions_result(result)
    catch ex
      exret = getActiveCompactions_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _getActiveCompactions
  function _getSiteConfiguration(inp::getSiteConfiguration_args)
    try
      result = getSiteConfiguration(inp.login)
      return getSiteConfiguration_result(result)
    catch ex
      exret = getSiteConfiguration_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _getSiteConfiguration
  function _getSystemConfiguration(inp::getSystemConfiguration_args)
    try
      result = getSystemConfiguration(inp.login)
      return getSystemConfiguration_result(result)
    catch ex
      exret = getSystemConfiguration_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _getSystemConfiguration
  _getTabletServers(inp::getTabletServers_args) = getTabletServers_result(getTabletServers(inp.login))
  function _removeProperty(inp::removeProperty_args)
    try
      removeProperty(inp.login, inp.property)
      return removeProperty_result()
    catch ex
      exret = removeProperty_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _removeProperty
  function _setProperty(inp::setProperty_args)
    try
      setProperty(inp.login, inp.property, inp.value)
      return setProperty_result()
    catch ex
      exret = setProperty_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _setProperty
  function _testClassLoad(inp::testClassLoad_args)
    try
      result = testClassLoad(inp.login, inp.className, inp.asTypeName)
      return testClassLoad_result(result)
    catch ex
      exret = testClassLoad_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _testClassLoad
  function _authenticateUser(inp::authenticateUser_args)
    try
      result = authenticateUser(inp.login, inp.user, inp.properties)
      return authenticateUser_result(result)
    catch ex
      exret = authenticateUser_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _authenticateUser
  function _changeUserAuthorizations(inp::changeUserAuthorizations_args)
    try
      changeUserAuthorizations(inp.login, inp.user, inp.authorizations)
      return changeUserAuthorizations_result()
    catch ex
      exret = changeUserAuthorizations_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _changeUserAuthorizations
  function _changeLocalUserPassword(inp::changeLocalUserPassword_args)
    try
      changeLocalUserPassword(inp.login, inp.user, inp.password)
      return changeLocalUserPassword_result()
    catch ex
      exret = changeLocalUserPassword_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _changeLocalUserPassword
  function _createLocalUser(inp::createLocalUser_args)
    try
      createLocalUser(inp.login, inp.user, inp.password)
      return createLocalUser_result()
    catch ex
      exret = createLocalUser_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _createLocalUser
  function _dropLocalUser(inp::dropLocalUser_args)
    try
      dropLocalUser(inp.login, inp.user)
      return dropLocalUser_result()
    catch ex
      exret = dropLocalUser_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _dropLocalUser
  function _getUserAuthorizations(inp::getUserAuthorizations_args)
    try
      result = getUserAuthorizations(inp.login, inp.user)
      return getUserAuthorizations_result(result)
    catch ex
      exret = getUserAuthorizations_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _getUserAuthorizations
  function _grantSystemPermission(inp::grantSystemPermission_args)
    try
      grantSystemPermission(inp.login, inp.user, inp.perm)
      return grantSystemPermission_result()
    catch ex
      exret = grantSystemPermission_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _grantSystemPermission
  function _grantTablePermission(inp::grantTablePermission_args)
    try
      grantTablePermission(inp.login, inp.user, inp.table, inp.perm)
      return grantTablePermission_result()
    catch ex
      exret = grantTablePermission_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _grantTablePermission
  function _hasSystemPermission(inp::hasSystemPermission_args)
    try
      result = hasSystemPermission(inp.login, inp.user, inp.perm)
      return hasSystemPermission_result(result)
    catch ex
      exret = hasSystemPermission_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _hasSystemPermission
  function _hasTablePermission(inp::hasTablePermission_args)
    try
      result = hasTablePermission(inp.login, inp.user, inp.table, inp.perm)
      return hasTablePermission_result(result)
    catch ex
      exret = hasTablePermission_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _hasTablePermission
  function _listLocalUsers(inp::listLocalUsers_args)
    try
      result = listLocalUsers(inp.login)
      return listLocalUsers_result(result)
    catch ex
      exret = listLocalUsers_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _listLocalUsers
  function _revokeSystemPermission(inp::revokeSystemPermission_args)
    try
      revokeSystemPermission(inp.login, inp.user, inp.perm)
      return revokeSystemPermission_result()
    catch ex
      exret = revokeSystemPermission_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _revokeSystemPermission
  function _revokeTablePermission(inp::revokeTablePermission_args)
    try
      revokeTablePermission(inp.login, inp.user, inp.table, inp.perm)
      return revokeTablePermission_result()
    catch ex
      exret = revokeTablePermission_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _revokeTablePermission
  function _createBatchScanner(inp::createBatchScanner_args)
    try
      result = createBatchScanner(inp.login, inp.tableName, inp.options)
      return createBatchScanner_result(result)
    catch ex
      exret = createBatchScanner_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _createBatchScanner
  function _createScanner(inp::createScanner_args)
    try
      result = createScanner(inp.login, inp.tableName, inp.options)
      return createScanner_result(result)
    catch ex
      exret = createScanner_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _createScanner
  function _hasNext(inp::hasNext_args)
    try
      result = hasNext(inp.scanner)
      return hasNext_result(result)
    catch ex
      exret = hasNext_result()
      isa(ex, UnknownScanner) && (set_field!(exret, :ouch1, ex); return exret)
      rethrow()
    end # try
  end #function _hasNext
  function _nextEntry(inp::nextEntry_args)
    try
      result = nextEntry(inp.scanner)
      return nextEntry_result(result)
    catch ex
      exret = nextEntry_result()
      isa(ex, NoMoreEntriesException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, UnknownScanner) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _nextEntry
  function _nextK(inp::nextK_args)
    try
      result = nextK(inp.scanner, inp.k)
      return nextK_result(result)
    catch ex
      exret = nextK_result()
      isa(ex, NoMoreEntriesException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, UnknownScanner) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _nextK
  function _closeScanner(inp::closeScanner_args)
    try
      closeScanner(inp.scanner)
      return closeScanner_result()
    catch ex
      exret = closeScanner_result()
      isa(ex, UnknownScanner) && (set_field!(exret, :ouch1, ex); return exret)
      rethrow()
    end # try
  end #function _closeScanner
  function _updateAndFlush(inp::updateAndFlush_args)
    try
      updateAndFlush(inp.login, inp.tableName, inp.cells)
      return updateAndFlush_result()
    catch ex
      exret = updateAndFlush_result()
      isa(ex, AccumuloException) && (set_field!(exret, :outch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      isa(ex, MutationsRejectedException) && (set_field!(exret, :ouch4, ex); return exret)
      rethrow()
    end # try
  end #function _updateAndFlush
  function _createWriter(inp::createWriter_args)
    try
      result = createWriter(inp.login, inp.tableName, inp.opts)
      return createWriter_result(result)
    catch ex
      exret = createWriter_result()
      isa(ex, AccumuloException) && (set_field!(exret, :outch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _createWriter
  _update(inp::update_args) = (update(); update_result())
  function _flush(inp::flush_args)
    try
      flush(inp.writer)
      return flush_result()
    catch ex
      exret = flush_result()
      isa(ex, UnknownWriter) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, MutationsRejectedException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _flush
  function _closeWriter(inp::closeWriter_args)
    try
      closeWriter(inp.writer)
      return closeWriter_result()
    catch ex
      exret = closeWriter_result()
      isa(ex, UnknownWriter) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, MutationsRejectedException) && (set_field!(exret, :ouch2, ex); return exret)
      rethrow()
    end # try
  end #function _closeWriter
  function _updateRowConditionally(inp::updateRowConditionally_args)
    try
      result = updateRowConditionally(inp.login, inp.tableName, inp.row, inp.updates)
      return updateRowConditionally_result(result)
    catch ex
      exret = updateRowConditionally_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _updateRowConditionally
  function _createConditionalWriter(inp::createConditionalWriter_args)
    try
      result = createConditionalWriter(inp.login, inp.tableName, inp.options)
      return createConditionalWriter_result(result)
    catch ex
      exret = createConditionalWriter_result()
      isa(ex, AccumuloException) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, TableNotFoundException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _createConditionalWriter
  function _updateRowsConditionally(inp::updateRowsConditionally_args)
    try
      result = updateRowsConditionally(inp.conditionalWriter, inp.updates)
      return updateRowsConditionally_result(result)
    catch ex
      exret = updateRowsConditionally_result()
      isa(ex, UnknownWriter) && (set_field!(exret, :ouch1, ex); return exret)
      isa(ex, AccumuloException) && (set_field!(exret, :ouch2, ex); return exret)
      isa(ex, AccumuloSecurityException) && (set_field!(exret, :ouch3, ex); return exret)
      rethrow()
    end # try
  end #function _updateRowsConditionally
  _closeConditionalWriter(inp::closeConditionalWriter_args) = (closeConditionalWriter(); closeConditionalWriter_result())
  _getRowRange(inp::getRowRange_args) = getRowRange_result(getRowRange(inp.row))
  _getFollowing(inp::getFollowing_args) = getFollowing_result(getFollowing(inp.key, inp.part))
end # type AccumuloProxyProcessor
process(p::AccumuloProxyProcessor, inp::TProtocol, outp::TProtocol) = process(p.tp, inp, outp)
distribute(p::AccumuloProxyProcessor) = distribute(p.tp)


# Server side methods to be defined by user:
# function login(principal::UTF8String, loginProperties::Dict{UTF8String,UTF8String})
#     # returns Vector{UInt8}
#     # throws ouch2::AccumuloSecurityException
# function addConstraint(login::Vector{UInt8}, tableName::UTF8String, constraintClassName::UTF8String)
#     # returns Int32
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function addSplits(login::Vector{UInt8}, tableName::UTF8String, splits::Set{Vector{UInt8}})
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function attachIterator(login::Vector{UInt8}, tableName::UTF8String, setting::IteratorSetting, scopes::Set{Int32})
#     # returns nothing
#     # throws ouch1::AccumuloSecurityException
#     # throws ouch2::AccumuloException
#     # throws ouch3::TableNotFoundException
# function checkIteratorConflicts(login::Vector{UInt8}, tableName::UTF8String, setting::IteratorSetting, scopes::Set{Int32})
#     # returns nothing
#     # throws ouch1::AccumuloSecurityException
#     # throws ouch2::AccumuloException
#     # throws ouch3::TableNotFoundException
# function clearLocatorCache(login::Vector{UInt8}, tableName::UTF8String)
#     # returns nothing
#     # throws ouch1::TableNotFoundException
# function cloneTable(login::Vector{UInt8}, tableName::UTF8String, newTableName::UTF8String, flush::Bool, propertiesToSet::Dict{UTF8String,UTF8String}, propertiesToExclude::Set{UTF8String})
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
#     # throws ouch4::TableExistsException
# function compactTable(login::Vector{UInt8}, tableName::UTF8String, startRow::Vector{UInt8}, endRow::Vector{UInt8}, iterators::Vector{IteratorSetting}, flush::Bool, wait::Bool, compactionStrategy::CompactionStrategyConfig)
#     # returns nothing
#     # throws ouch1::AccumuloSecurityException
#     # throws ouch2::TableNotFoundException
#     # throws ouch3::AccumuloException
# function cancelCompaction(login::Vector{UInt8}, tableName::UTF8String)
#     # returns nothing
#     # throws ouch1::AccumuloSecurityException
#     # throws ouch2::TableNotFoundException
#     # throws ouch3::AccumuloException
# function createTable(login::Vector{UInt8}, tableName::UTF8String, versioningIter::Bool, _type::Int32)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableExistsException
# function deleteTable(login::Vector{UInt8}, tableName::UTF8String)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function deleteRows(login::Vector{UInt8}, tableName::UTF8String, startRow::Vector{UInt8}, endRow::Vector{UInt8})
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function exportTable(login::Vector{UInt8}, tableName::UTF8String, exportDir::UTF8String)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function flushTable(login::Vector{UInt8}, tableName::UTF8String, startRow::Vector{UInt8}, endRow::Vector{UInt8}, wait::Bool)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function getDiskUsage(login::Vector{UInt8}, tables::Set{UTF8String})
#     # returns Vector{DiskUsage}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function getLocalityGroups(login::Vector{UInt8}, tableName::UTF8String)
#     # returns Dict{UTF8String,Set{UTF8String}}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function getIteratorSetting(login::Vector{UInt8}, tableName::UTF8String, iteratorName::UTF8String, scope::Int32)
#     # returns IteratorSetting
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function getMaxRow(login::Vector{UInt8}, tableName::UTF8String, auths::Set{Vector{UInt8}}, startRow::Vector{UInt8}, startInclusive::Bool, endRow::Vector{UInt8}, endInclusive::Bool)
#     # returns Vector{UInt8}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function getTableProperties(login::Vector{UInt8}, tableName::UTF8String)
#     # returns Dict{UTF8String,UTF8String}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function importDirectory(login::Vector{UInt8}, tableName::UTF8String, importDir::UTF8String, failureDir::UTF8String, setTime::Bool)
#     # returns nothing
#     # throws ouch1::TableNotFoundException
#     # throws ouch3::AccumuloException
#     # throws ouch4::AccumuloSecurityException
# function importTable(login::Vector{UInt8}, tableName::UTF8String, importDir::UTF8String)
#     # returns nothing
#     # throws ouch1::TableExistsException
#     # throws ouch2::AccumuloException
#     # throws ouch3::AccumuloSecurityException
# function listSplits(login::Vector{UInt8}, tableName::UTF8String, maxSplits::Int32)
#     # returns Vector{Vector{UInt8}}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function listTables(login::Vector{UInt8})
#     # returns Set{UTF8String}
# function listIterators(login::Vector{UInt8}, tableName::UTF8String)
#     # returns Dict{UTF8String,Set{Int32}}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function listConstraints(login::Vector{UInt8}, tableName::UTF8String)
#     # returns Dict{UTF8String,Int32}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function mergeTablets(login::Vector{UInt8}, tableName::UTF8String, startRow::Vector{UInt8}, endRow::Vector{UInt8})
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function offlineTable(login::Vector{UInt8}, tableName::UTF8String, wait::Bool)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function onlineTable(login::Vector{UInt8}, tableName::UTF8String, wait::Bool)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function removeConstraint(login::Vector{UInt8}, tableName::UTF8String, constraint::Int32)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function removeIterator(login::Vector{UInt8}, tableName::UTF8String, iterName::UTF8String, scopes::Set{Int32})
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function removeTableProperty(login::Vector{UInt8}, tableName::UTF8String, property::UTF8String)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function renameTable(login::Vector{UInt8}, oldTableName::UTF8String, newTableName::UTF8String)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
#     # throws ouch4::TableExistsException
# function setLocalityGroups(login::Vector{UInt8}, tableName::UTF8String, groups::Dict{UTF8String,Set{UTF8String}})
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function setTableProperty(login::Vector{UInt8}, tableName::UTF8String, property::UTF8String, value::UTF8String)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function splitRangeByTablets(login::Vector{UInt8}, tableName::UTF8String, range::Range, maxSplits::Int32)
#     # returns Set{Range}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function tableExists(login::Vector{UInt8}, tableName::UTF8String)
#     # returns Bool
# function tableIdMap(login::Vector{UInt8})
#     # returns Dict{UTF8String,UTF8String}
# function testTableClassLoad(login::Vector{UInt8}, tableName::UTF8String, className::UTF8String, asTypeName::UTF8String)
#     # returns Bool
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function pingTabletServer(login::Vector{UInt8}, tserver::UTF8String)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function getActiveScans(login::Vector{UInt8}, tserver::UTF8String)
#     # returns Vector{ActiveScan}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function getActiveCompactions(login::Vector{UInt8}, tserver::UTF8String)
#     # returns Vector{ActiveCompaction}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function getSiteConfiguration(login::Vector{UInt8})
#     # returns Dict{UTF8String,UTF8String}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function getSystemConfiguration(login::Vector{UInt8})
#     # returns Dict{UTF8String,UTF8String}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function getTabletServers(login::Vector{UInt8})
#     # returns Vector{UTF8String}
# function removeProperty(login::Vector{UInt8}, property::UTF8String)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function setProperty(login::Vector{UInt8}, property::UTF8String, value::UTF8String)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function testClassLoad(login::Vector{UInt8}, className::UTF8String, asTypeName::UTF8String)
#     # returns Bool
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function authenticateUser(login::Vector{UInt8}, user::UTF8String, properties::Dict{UTF8String,UTF8String})
#     # returns Bool
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function changeUserAuthorizations(login::Vector{UInt8}, user::UTF8String, authorizations::Set{Vector{UInt8}})
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function changeLocalUserPassword(login::Vector{UInt8}, user::UTF8String, password::Vector{UInt8})
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function createLocalUser(login::Vector{UInt8}, user::UTF8String, password::Vector{UInt8})
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function dropLocalUser(login::Vector{UInt8}, user::UTF8String)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function getUserAuthorizations(login::Vector{UInt8}, user::UTF8String)
#     # returns Vector{Vector{UInt8}}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function grantSystemPermission(login::Vector{UInt8}, user::UTF8String, perm::Int32)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function grantTablePermission(login::Vector{UInt8}, user::UTF8String, table::UTF8String, perm::Int32)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function hasSystemPermission(login::Vector{UInt8}, user::UTF8String, perm::Int32)
#     # returns Bool
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function hasTablePermission(login::Vector{UInt8}, user::UTF8String, table::UTF8String, perm::Int32)
#     # returns Bool
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function listLocalUsers(login::Vector{UInt8})
#     # returns Set{UTF8String}
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function revokeSystemPermission(login::Vector{UInt8}, user::UTF8String, perm::Int32)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
# function revokeTablePermission(login::Vector{UInt8}, user::UTF8String, table::UTF8String, perm::Int32)
#     # returns nothing
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function createBatchScanner(login::Vector{UInt8}, tableName::UTF8String, options::BatchScanOptions)
#     # returns UTF8String
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function createScanner(login::Vector{UInt8}, tableName::UTF8String, options::ScanOptions)
#     # returns UTF8String
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function hasNext(scanner::UTF8String)
#     # returns Bool
#     # throws ouch1::UnknownScanner
# function nextEntry(scanner::UTF8String)
#     # returns KeyValueAndPeek
#     # throws ouch1::NoMoreEntriesException
#     # throws ouch2::UnknownScanner
#     # throws ouch3::AccumuloSecurityException
# function nextK(scanner::UTF8String, k::Int32)
#     # returns ScanResult
#     # throws ouch1::NoMoreEntriesException
#     # throws ouch2::UnknownScanner
#     # throws ouch3::AccumuloSecurityException
# function closeScanner(scanner::UTF8String)
#     # returns nothing
#     # throws ouch1::UnknownScanner
# function updateAndFlush(login::Vector{UInt8}, tableName::UTF8String, cells::Dict{Vector{UInt8},Vector{ColumnUpdate}})
#     # returns nothing
#     # throws outch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
#     # throws ouch4::MutationsRejectedException
# function createWriter(login::Vector{UInt8}, tableName::UTF8String, opts::WriterOptions)
#     # returns UTF8String
#     # throws outch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function update(writer::UTF8String, cells::Dict{Vector{UInt8},Vector{ColumnUpdate}})
#     # returns nothing
# function flush(writer::UTF8String)
#     # returns nothing
#     # throws ouch1::UnknownWriter
#     # throws ouch2::MutationsRejectedException
# function closeWriter(writer::UTF8String)
#     # returns nothing
#     # throws ouch1::UnknownWriter
#     # throws ouch2::MutationsRejectedException
# function updateRowConditionally(login::Vector{UInt8}, tableName::UTF8String, row::Vector{UInt8}, updates::ConditionalUpdates)
#     # returns Int32
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function createConditionalWriter(login::Vector{UInt8}, tableName::UTF8String, options::ConditionalWriterOptions)
#     # returns UTF8String
#     # throws ouch1::AccumuloException
#     # throws ouch2::AccumuloSecurityException
#     # throws ouch3::TableNotFoundException
# function updateRowsConditionally(conditionalWriter::UTF8String, updates::Dict{Vector{UInt8},ConditionalUpdates})
#     # returns Dict{Vector{UInt8},Int32}
#     # throws ouch1::UnknownWriter
#     # throws ouch2::AccumuloException
#     # throws ouch3::AccumuloSecurityException
# function closeConditionalWriter(conditionalWriter::UTF8String)
#     # returns nothing
# function getRowRange(row::Vector{UInt8})
#     # returns Range
# function getFollowing(key::Key, part::Int32)
#     # returns Key


# Client implementation for AccumuloProxy service
type AccumuloProxyClient <: AccumuloProxyClientBase
  p::TProtocol
  seqid::Int32
  AccumuloProxyClient(p::TProtocol) = new(p, 0)
end # type AccumuloProxyClient

# Client callable method for login
function login(c::AccumuloProxyClientBase, principal::UTF8String, loginProperties::Dict{UTF8String,UTF8String})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "login", MessageType.CALL, c.seqid)
  inp = login_args()
  set_field!(inp, :principal, principal)
  set_field!(inp, :loginProperties, loginProperties)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, login_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function login

# Client callable method for addConstraint
function addConstraint(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, constraintClassName::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "addConstraint", MessageType.CALL, c.seqid)
  inp = addConstraint_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :constraintClassName, constraintClassName)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, addConstraint_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function addConstraint

# Client callable method for addSplits
function addSplits(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, splits::Set{Vector{UInt8}})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "addSplits", MessageType.CALL, c.seqid)
  inp = addSplits_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :splits, splits)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, addSplits_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  nothing
end # function addSplits

# Client callable method for attachIterator
function attachIterator(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, setting::IteratorSetting, scopes::Set{Int32})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "attachIterator", MessageType.CALL, c.seqid)
  inp = attachIterator_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :setting, setting)
  set_field!(inp, :scopes, scopes)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, attachIterator_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  nothing
end # function attachIterator

# Client callable method for checkIteratorConflicts
function checkIteratorConflicts(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, setting::IteratorSetting, scopes::Set{Int32})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "checkIteratorConflicts", MessageType.CALL, c.seqid)
  inp = checkIteratorConflicts_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :setting, setting)
  set_field!(inp, :scopes, scopes)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, checkIteratorConflicts_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  nothing
end # function checkIteratorConflicts

# Client callable method for clearLocatorCache
function clearLocatorCache(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "clearLocatorCache", MessageType.CALL, c.seqid)
  inp = clearLocatorCache_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, clearLocatorCache_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  nothing
end # function clearLocatorCache

# Client callable method for cloneTable
function cloneTable(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, newTableName::UTF8String, flush::Bool, propertiesToSet::Dict{UTF8String,UTF8String}, propertiesToExclude::Set{UTF8String})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "cloneTable", MessageType.CALL, c.seqid)
  inp = cloneTable_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :newTableName, newTableName)
  set_field!(inp, :flush, flush)
  set_field!(inp, :propertiesToSet, propertiesToSet)
  set_field!(inp, :propertiesToExclude, propertiesToExclude)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, cloneTable_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :ouch4) && throw(get_field(outp, :ouch4))
  nothing
end # function cloneTable

# Client callable method for compactTable
function compactTable(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, startRow::Vector{UInt8}, endRow::Vector{UInt8}, iterators::Vector{IteratorSetting}, flush::Bool, wait::Bool, compactionStrategy::CompactionStrategyConfig)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "compactTable", MessageType.CALL, c.seqid)
  inp = compactTable_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :startRow, startRow)
  set_field!(inp, :endRow, endRow)
  set_field!(inp, :iterators, iterators)
  set_field!(inp, :flush, flush)
  set_field!(inp, :wait, wait)
  set_field!(inp, :compactionStrategy, compactionStrategy)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, compactTable_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  nothing
end # function compactTable

# Client callable method for cancelCompaction
function cancelCompaction(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "cancelCompaction", MessageType.CALL, c.seqid)
  inp = cancelCompaction_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, cancelCompaction_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  nothing
end # function cancelCompaction

# Client callable method for createTable
function createTable(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, versioningIter::Bool, _type::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "createTable", MessageType.CALL, c.seqid)
  inp = createTable_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :versioningIter, versioningIter)
  set_field!(inp, :_type, _type)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, createTable_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  nothing
end # function createTable

# Client callable method for deleteTable
function deleteTable(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "deleteTable", MessageType.CALL, c.seqid)
  inp = deleteTable_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, deleteTable_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  nothing
end # function deleteTable

# Client callable method for deleteRows
function deleteRows(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, startRow::Vector{UInt8}, endRow::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "deleteRows", MessageType.CALL, c.seqid)
  inp = deleteRows_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :startRow, startRow)
  set_field!(inp, :endRow, endRow)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, deleteRows_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  nothing
end # function deleteRows

# Client callable method for exportTable
function exportTable(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, exportDir::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "exportTable", MessageType.CALL, c.seqid)
  inp = exportTable_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :exportDir, exportDir)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, exportTable_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  nothing
end # function exportTable

# Client callable method for flushTable
function flushTable(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, startRow::Vector{UInt8}, endRow::Vector{UInt8}, wait::Bool)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "flushTable", MessageType.CALL, c.seqid)
  inp = flushTable_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :startRow, startRow)
  set_field!(inp, :endRow, endRow)
  set_field!(inp, :wait, wait)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, flushTable_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  nothing
end # function flushTable

# Client callable method for getDiskUsage
function getDiskUsage(c::AccumuloProxyClientBase, login::Vector{UInt8}, tables::Set{UTF8String})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "getDiskUsage", MessageType.CALL, c.seqid)
  inp = getDiskUsage_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tables, tables)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, getDiskUsage_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getDiskUsage

# Client callable method for getLocalityGroups
function getLocalityGroups(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "getLocalityGroups", MessageType.CALL, c.seqid)
  inp = getLocalityGroups_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, getLocalityGroups_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getLocalityGroups

# Client callable method for getIteratorSetting
function getIteratorSetting(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, iteratorName::UTF8String, scope::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "getIteratorSetting", MessageType.CALL, c.seqid)
  inp = getIteratorSetting_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :iteratorName, iteratorName)
  set_field!(inp, :scope, scope)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, getIteratorSetting_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getIteratorSetting

# Client callable method for getMaxRow
function getMaxRow(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, auths::Set{Vector{UInt8}}, startRow::Vector{UInt8}, startInclusive::Bool, endRow::Vector{UInt8}, endInclusive::Bool)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "getMaxRow", MessageType.CALL, c.seqid)
  inp = getMaxRow_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :auths, auths)
  set_field!(inp, :startRow, startRow)
  set_field!(inp, :startInclusive, startInclusive)
  set_field!(inp, :endRow, endRow)
  set_field!(inp, :endInclusive, endInclusive)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, getMaxRow_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getMaxRow

# Client callable method for getTableProperties
function getTableProperties(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "getTableProperties", MessageType.CALL, c.seqid)
  inp = getTableProperties_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, getTableProperties_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getTableProperties

# Client callable method for importDirectory
function importDirectory(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, importDir::UTF8String, failureDir::UTF8String, setTime::Bool)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "importDirectory", MessageType.CALL, c.seqid)
  inp = importDirectory_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :importDir, importDir)
  set_field!(inp, :failureDir, failureDir)
  set_field!(inp, :setTime, setTime)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, importDirectory_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :ouch4) && throw(get_field(outp, :ouch4))
  nothing
end # function importDirectory

# Client callable method for importTable
function importTable(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, importDir::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "importTable", MessageType.CALL, c.seqid)
  inp = importTable_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :importDir, importDir)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, importTable_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  nothing
end # function importTable

# Client callable method for listSplits
function listSplits(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, maxSplits::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "listSplits", MessageType.CALL, c.seqid)
  inp = listSplits_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :maxSplits, maxSplits)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, listSplits_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function listSplits

# Client callable method for listTables
function listTables(c::AccumuloProxyClientBase, login::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "listTables", MessageType.CALL, c.seqid)
  inp = listTables_args()
  set_field!(inp, :login, login)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, listTables_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function listTables

# Client callable method for listIterators
function listIterators(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "listIterators", MessageType.CALL, c.seqid)
  inp = listIterators_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, listIterators_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function listIterators

# Client callable method for listConstraints
function listConstraints(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "listConstraints", MessageType.CALL, c.seqid)
  inp = listConstraints_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, listConstraints_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function listConstraints

# Client callable method for mergeTablets
function mergeTablets(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, startRow::Vector{UInt8}, endRow::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "mergeTablets", MessageType.CALL, c.seqid)
  inp = mergeTablets_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :startRow, startRow)
  set_field!(inp, :endRow, endRow)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, mergeTablets_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  nothing
end # function mergeTablets

# Client callable method for offlineTable
function offlineTable(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, wait::Bool)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "offlineTable", MessageType.CALL, c.seqid)
  inp = offlineTable_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :wait, wait)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, offlineTable_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  nothing
end # function offlineTable

# Client callable method for onlineTable
function onlineTable(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, wait::Bool)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "onlineTable", MessageType.CALL, c.seqid)
  inp = onlineTable_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :wait, wait)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, onlineTable_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  nothing
end # function onlineTable

# Client callable method for removeConstraint
function removeConstraint(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, constraint::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "removeConstraint", MessageType.CALL, c.seqid)
  inp = removeConstraint_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :constraint, constraint)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, removeConstraint_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  nothing
end # function removeConstraint

# Client callable method for removeIterator
function removeIterator(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, iterName::UTF8String, scopes::Set{Int32})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "removeIterator", MessageType.CALL, c.seqid)
  inp = removeIterator_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :iterName, iterName)
  set_field!(inp, :scopes, scopes)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, removeIterator_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  nothing
end # function removeIterator

# Client callable method for removeTableProperty
function removeTableProperty(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, property::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "removeTableProperty", MessageType.CALL, c.seqid)
  inp = removeTableProperty_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :property, property)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, removeTableProperty_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  nothing
end # function removeTableProperty

# Client callable method for renameTable
function renameTable(c::AccumuloProxyClientBase, login::Vector{UInt8}, oldTableName::UTF8String, newTableName::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "renameTable", MessageType.CALL, c.seqid)
  inp = renameTable_args()
  set_field!(inp, :login, login)
  set_field!(inp, :oldTableName, oldTableName)
  set_field!(inp, :newTableName, newTableName)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, renameTable_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :ouch4) && throw(get_field(outp, :ouch4))
  nothing
end # function renameTable

# Client callable method for setLocalityGroups
function setLocalityGroups(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, groups::Dict{UTF8String,Set{UTF8String}})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "setLocalityGroups", MessageType.CALL, c.seqid)
  inp = setLocalityGroups_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :groups, groups)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, setLocalityGroups_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  nothing
end # function setLocalityGroups

# Client callable method for setTableProperty
function setTableProperty(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, property::UTF8String, value::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "setTableProperty", MessageType.CALL, c.seqid)
  inp = setTableProperty_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :property, property)
  set_field!(inp, :value, value)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, setTableProperty_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  nothing
end # function setTableProperty

# Client callable method for splitRangeByTablets
function splitRangeByTablets(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, range::Range, maxSplits::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "splitRangeByTablets", MessageType.CALL, c.seqid)
  inp = splitRangeByTablets_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :range, range)
  set_field!(inp, :maxSplits, maxSplits)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, splitRangeByTablets_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function splitRangeByTablets

# Client callable method for tableExists
function tableExists(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "tableExists", MessageType.CALL, c.seqid)
  inp = tableExists_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, tableExists_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function tableExists

# Client callable method for tableIdMap
function tableIdMap(c::AccumuloProxyClientBase, login::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "tableIdMap", MessageType.CALL, c.seqid)
  inp = tableIdMap_args()
  set_field!(inp, :login, login)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, tableIdMap_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function tableIdMap

# Client callable method for testTableClassLoad
function testTableClassLoad(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, className::UTF8String, asTypeName::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "testTableClassLoad", MessageType.CALL, c.seqid)
  inp = testTableClassLoad_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :className, className)
  set_field!(inp, :asTypeName, asTypeName)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, testTableClassLoad_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function testTableClassLoad

# Client callable method for pingTabletServer
function pingTabletServer(c::AccumuloProxyClientBase, login::Vector{UInt8}, tserver::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "pingTabletServer", MessageType.CALL, c.seqid)
  inp = pingTabletServer_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tserver, tserver)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, pingTabletServer_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  nothing
end # function pingTabletServer

# Client callable method for getActiveScans
function getActiveScans(c::AccumuloProxyClientBase, login::Vector{UInt8}, tserver::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "getActiveScans", MessageType.CALL, c.seqid)
  inp = getActiveScans_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tserver, tserver)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, getActiveScans_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getActiveScans

# Client callable method for getActiveCompactions
function getActiveCompactions(c::AccumuloProxyClientBase, login::Vector{UInt8}, tserver::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "getActiveCompactions", MessageType.CALL, c.seqid)
  inp = getActiveCompactions_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tserver, tserver)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, getActiveCompactions_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getActiveCompactions

# Client callable method for getSiteConfiguration
function getSiteConfiguration(c::AccumuloProxyClientBase, login::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "getSiteConfiguration", MessageType.CALL, c.seqid)
  inp = getSiteConfiguration_args()
  set_field!(inp, :login, login)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, getSiteConfiguration_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getSiteConfiguration

# Client callable method for getSystemConfiguration
function getSystemConfiguration(c::AccumuloProxyClientBase, login::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "getSystemConfiguration", MessageType.CALL, c.seqid)
  inp = getSystemConfiguration_args()
  set_field!(inp, :login, login)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, getSystemConfiguration_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getSystemConfiguration

# Client callable method for getTabletServers
function getTabletServers(c::AccumuloProxyClientBase, login::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "getTabletServers", MessageType.CALL, c.seqid)
  inp = getTabletServers_args()
  set_field!(inp, :login, login)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, getTabletServers_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getTabletServers

# Client callable method for removeProperty
function removeProperty(c::AccumuloProxyClientBase, login::Vector{UInt8}, property::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "removeProperty", MessageType.CALL, c.seqid)
  inp = removeProperty_args()
  set_field!(inp, :login, login)
  set_field!(inp, :property, property)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, removeProperty_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  nothing
end # function removeProperty

# Client callable method for setProperty
function setProperty(c::AccumuloProxyClientBase, login::Vector{UInt8}, property::UTF8String, value::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "setProperty", MessageType.CALL, c.seqid)
  inp = setProperty_args()
  set_field!(inp, :login, login)
  set_field!(inp, :property, property)
  set_field!(inp, :value, value)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, setProperty_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  nothing
end # function setProperty

# Client callable method for testClassLoad
function testClassLoad(c::AccumuloProxyClientBase, login::Vector{UInt8}, className::UTF8String, asTypeName::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "testClassLoad", MessageType.CALL, c.seqid)
  inp = testClassLoad_args()
  set_field!(inp, :login, login)
  set_field!(inp, :className, className)
  set_field!(inp, :asTypeName, asTypeName)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, testClassLoad_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function testClassLoad

# Client callable method for authenticateUser
function authenticateUser(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::UTF8String, properties::Dict{UTF8String,UTF8String})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "authenticateUser", MessageType.CALL, c.seqid)
  inp = authenticateUser_args()
  set_field!(inp, :login, login)
  set_field!(inp, :user, user)
  set_field!(inp, :properties, properties)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, authenticateUser_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function authenticateUser

# Client callable method for changeUserAuthorizations
function changeUserAuthorizations(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::UTF8String, authorizations::Set{Vector{UInt8}})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "changeUserAuthorizations", MessageType.CALL, c.seqid)
  inp = changeUserAuthorizations_args()
  set_field!(inp, :login, login)
  set_field!(inp, :user, user)
  set_field!(inp, :authorizations, authorizations)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, changeUserAuthorizations_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  nothing
end # function changeUserAuthorizations

# Client callable method for changeLocalUserPassword
function changeLocalUserPassword(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::UTF8String, password::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "changeLocalUserPassword", MessageType.CALL, c.seqid)
  inp = changeLocalUserPassword_args()
  set_field!(inp, :login, login)
  set_field!(inp, :user, user)
  set_field!(inp, :password, password)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, changeLocalUserPassword_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  nothing
end # function changeLocalUserPassword

# Client callable method for createLocalUser
function createLocalUser(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::UTF8String, password::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "createLocalUser", MessageType.CALL, c.seqid)
  inp = createLocalUser_args()
  set_field!(inp, :login, login)
  set_field!(inp, :user, user)
  set_field!(inp, :password, password)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, createLocalUser_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  nothing
end # function createLocalUser

# Client callable method for dropLocalUser
function dropLocalUser(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "dropLocalUser", MessageType.CALL, c.seqid)
  inp = dropLocalUser_args()
  set_field!(inp, :login, login)
  set_field!(inp, :user, user)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, dropLocalUser_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  nothing
end # function dropLocalUser

# Client callable method for getUserAuthorizations
function getUserAuthorizations(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "getUserAuthorizations", MessageType.CALL, c.seqid)
  inp = getUserAuthorizations_args()
  set_field!(inp, :login, login)
  set_field!(inp, :user, user)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, getUserAuthorizations_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getUserAuthorizations

# Client callable method for grantSystemPermission
function grantSystemPermission(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::UTF8String, perm::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "grantSystemPermission", MessageType.CALL, c.seqid)
  inp = grantSystemPermission_args()
  set_field!(inp, :login, login)
  set_field!(inp, :user, user)
  set_field!(inp, :perm, perm)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, grantSystemPermission_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  nothing
end # function grantSystemPermission

# Client callable method for grantTablePermission
function grantTablePermission(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::UTF8String, table::UTF8String, perm::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "grantTablePermission", MessageType.CALL, c.seqid)
  inp = grantTablePermission_args()
  set_field!(inp, :login, login)
  set_field!(inp, :user, user)
  set_field!(inp, :table, table)
  set_field!(inp, :perm, perm)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, grantTablePermission_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  nothing
end # function grantTablePermission

# Client callable method for hasSystemPermission
function hasSystemPermission(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::UTF8String, perm::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "hasSystemPermission", MessageType.CALL, c.seqid)
  inp = hasSystemPermission_args()
  set_field!(inp, :login, login)
  set_field!(inp, :user, user)
  set_field!(inp, :perm, perm)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, hasSystemPermission_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function hasSystemPermission

# Client callable method for hasTablePermission
function hasTablePermission(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::UTF8String, table::UTF8String, perm::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "hasTablePermission", MessageType.CALL, c.seqid)
  inp = hasTablePermission_args()
  set_field!(inp, :login, login)
  set_field!(inp, :user, user)
  set_field!(inp, :table, table)
  set_field!(inp, :perm, perm)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, hasTablePermission_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function hasTablePermission

# Client callable method for listLocalUsers
function listLocalUsers(c::AccumuloProxyClientBase, login::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "listLocalUsers", MessageType.CALL, c.seqid)
  inp = listLocalUsers_args()
  set_field!(inp, :login, login)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, listLocalUsers_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function listLocalUsers

# Client callable method for revokeSystemPermission
function revokeSystemPermission(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::UTF8String, perm::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "revokeSystemPermission", MessageType.CALL, c.seqid)
  inp = revokeSystemPermission_args()
  set_field!(inp, :login, login)
  set_field!(inp, :user, user)
  set_field!(inp, :perm, perm)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, revokeSystemPermission_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  nothing
end # function revokeSystemPermission

# Client callable method for revokeTablePermission
function revokeTablePermission(c::AccumuloProxyClientBase, login::Vector{UInt8}, user::UTF8String, table::UTF8String, perm::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "revokeTablePermission", MessageType.CALL, c.seqid)
  inp = revokeTablePermission_args()
  set_field!(inp, :login, login)
  set_field!(inp, :user, user)
  set_field!(inp, :table, table)
  set_field!(inp, :perm, perm)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, revokeTablePermission_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  nothing
end # function revokeTablePermission

# Client callable method for createBatchScanner
function createBatchScanner(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, options::BatchScanOptions)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "createBatchScanner", MessageType.CALL, c.seqid)
  inp = createBatchScanner_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :options, options)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, createBatchScanner_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function createBatchScanner

# Client callable method for createScanner
function createScanner(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, options::ScanOptions)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "createScanner", MessageType.CALL, c.seqid)
  inp = createScanner_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :options, options)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, createScanner_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function createScanner

# Client callable method for hasNext
function hasNext(c::AccumuloProxyClientBase, scanner::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "hasNext", MessageType.CALL, c.seqid)
  inp = hasNext_args()
  set_field!(inp, :scanner, scanner)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, hasNext_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function hasNext

# Client callable method for nextEntry
function nextEntry(c::AccumuloProxyClientBase, scanner::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "nextEntry", MessageType.CALL, c.seqid)
  inp = nextEntry_args()
  set_field!(inp, :scanner, scanner)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, nextEntry_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function nextEntry

# Client callable method for nextK
function nextK(c::AccumuloProxyClientBase, scanner::UTF8String, k::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "nextK", MessageType.CALL, c.seqid)
  inp = nextK_args()
  set_field!(inp, :scanner, scanner)
  set_field!(inp, :k, k)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, nextK_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function nextK

# Client callable method for closeScanner
function closeScanner(c::AccumuloProxyClientBase, scanner::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "closeScanner", MessageType.CALL, c.seqid)
  inp = closeScanner_args()
  set_field!(inp, :scanner, scanner)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, closeScanner_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  nothing
end # function closeScanner

# Client callable method for updateAndFlush
function updateAndFlush(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, cells::Dict{Vector{UInt8},Vector{ColumnUpdate}})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "updateAndFlush", MessageType.CALL, c.seqid)
  inp = updateAndFlush_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :cells, cells)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, updateAndFlush_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :outch1) && throw(get_field(outp, :outch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :ouch4) && throw(get_field(outp, :ouch4))
  nothing
end # function updateAndFlush

# Client callable method for createWriter
function createWriter(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, opts::WriterOptions)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "createWriter", MessageType.CALL, c.seqid)
  inp = createWriter_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :opts, opts)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, createWriter_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :outch1) && throw(get_field(outp, :outch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function createWriter

# Client callable method for update
function update(c::AccumuloProxyClientBase, writer::UTF8String, cells::Dict{Vector{UInt8},Vector{ColumnUpdate}})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "update", MessageType.CALL, c.seqid)
  inp = update_args()
  set_field!(inp, :writer, writer)
  set_field!(inp, :cells, cells)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, update_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  nothing
end # function update

# Client callable method for flush
function flush(c::AccumuloProxyClientBase, writer::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "flush", MessageType.CALL, c.seqid)
  inp = flush_args()
  set_field!(inp, :writer, writer)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, flush_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  nothing
end # function flush

# Client callable method for closeWriter
function closeWriter(c::AccumuloProxyClientBase, writer::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "closeWriter", MessageType.CALL, c.seqid)
  inp = closeWriter_args()
  set_field!(inp, :writer, writer)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, closeWriter_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  nothing
end # function closeWriter

# Client callable method for updateRowConditionally
function updateRowConditionally(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, row::Vector{UInt8}, updates::ConditionalUpdates)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "updateRowConditionally", MessageType.CALL, c.seqid)
  inp = updateRowConditionally_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :row, row)
  set_field!(inp, :updates, updates)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, updateRowConditionally_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function updateRowConditionally

# Client callable method for createConditionalWriter
function createConditionalWriter(c::AccumuloProxyClientBase, login::Vector{UInt8}, tableName::UTF8String, options::ConditionalWriterOptions)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "createConditionalWriter", MessageType.CALL, c.seqid)
  inp = createConditionalWriter_args()
  set_field!(inp, :login, login)
  set_field!(inp, :tableName, tableName)
  set_field!(inp, :options, options)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, createConditionalWriter_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function createConditionalWriter

# Client callable method for updateRowsConditionally
function updateRowsConditionally(c::AccumuloProxyClientBase, conditionalWriter::UTF8String, updates::Dict{Vector{UInt8},ConditionalUpdates})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "updateRowsConditionally", MessageType.CALL, c.seqid)
  inp = updateRowsConditionally_args()
  set_field!(inp, :conditionalWriter, conditionalWriter)
  set_field!(inp, :updates, updates)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, updateRowsConditionally_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :ouch1) && throw(get_field(outp, :ouch1))
  has_field(outp, :ouch2) && throw(get_field(outp, :ouch2))
  has_field(outp, :ouch3) && throw(get_field(outp, :ouch3))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function updateRowsConditionally

# Client callable method for closeConditionalWriter
function closeConditionalWriter(c::AccumuloProxyClientBase, conditionalWriter::UTF8String)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "closeConditionalWriter", MessageType.CALL, c.seqid)
  inp = closeConditionalWriter_args()
  set_field!(inp, :conditionalWriter, conditionalWriter)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, closeConditionalWriter_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  nothing
end # function closeConditionalWriter

# Client callable method for getRowRange
function getRowRange(c::AccumuloProxyClientBase, row::Vector{UInt8})
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "getRowRange", MessageType.CALL, c.seqid)
  inp = getRowRange_args()
  set_field!(inp, :row, row)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, getRowRange_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getRowRange

# Client callable method for getFollowing
function getFollowing(c::AccumuloProxyClientBase, key::Key, part::Int32)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  writeMessageBegin(p, "getFollowing", MessageType.CALL, c.seqid)
  inp = getFollowing_args()
  set_field!(inp, :key, key)
  set_field!(inp, :part, part)
  write(p, inp)
  writeMessageEnd(p)
  flush(p.t)
  
  (fname, mtype, rseqid) = readMessageBegin(p)
  (mtype == MessageType.EXCEPTION) && throw(read(p, TApplicationException()))
  outp = read(p, getFollowing_result())
  readMessageEnd(p)
  (rseqid != c.seqid) && throw(TApplicationException(ApplicationExceptionType.BAD_SEQUENCE_ID, "response sequence id $rseqid did not match request ($(c.seqid))"))
  has_field(outp, :success) && (return get_field(outp, :success))
  throw(TApplicationException(ApplicationExceptionType.MISSING_RESULT, "retrieve failed: unknown result"))
end # function getFollowing

